<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Concepts</title>
    <link rel="stylesheet" href="stylesth.css">
</head>
<body>
    <header>
        <h1>Algorithm Concepts</h1>
    </header>

    <main>
        <h2>1. Problems in Nature</h2>
        <p>
            <strong>Iteration:</strong> In computer programs, where the same task repeats over and over.<br>
            <strong>Recursion:</strong> The way trees branch out or rivers split into smaller streams. This is similar to recursion, where a problem is broken into smaller, repeating parts.<br>
            <strong>Backtracking:</strong> Picture ants searching for food. They try different paths, and if one doesn’t work, they go back and try another. This is backtracking, where you explore different options and go back if needed.
        </p>

        <h2>2. Space and Time Efficiency</h2>
        <p>
            <strong>Space Efficiency:</strong> This refers to how much memory the program uses. Using too much memory can slow things down or cause problems.<br>
            <strong>Time Efficiency:</strong> This is about how fast a program runs. If a program is slow, it might not work well, especially with lots of data.<br>
            <strong>Why It Matters:</strong> Efficient use of memory and time helps programs handle larger tasks without slowing down or using too many resources. For example, when you're using an app that shows live updates (like sports scores), you want it to load quickly without crashing.
        </p>

        <h2>3. Tree Data Structures</h2>
        <p>
            <strong>Binary Search Tree (BST):</strong> Imagine a phone book where names are sorted in order. You can quickly find any name, but if the book becomes unbalanced (like a straight list), it becomes slower.<br>
            <strong>2-3 Tree:</strong> This is a more balanced tree that helps keep things organized and fast.<br>
            <strong>AVL Tree:</strong> This tree keeps itself balanced by adjusting when necessary, though it’s a bit more complex.<br>
            <strong>Red-Black Tree:</strong> This is another balanced tree that requires fewer adjustments, making it easier to maintain.<br>
            <strong>Heap:</strong> A heap is like a to-do list where the most important task is always on top, making it easier to find.<br>
            <strong>Trie:</strong> This is a tree used to store strings (like words), which makes it very fast for searching.
        </p>

        <h2>4. Array Query Algorithms</h2>
        <p>
            <strong>Segment Trees:</strong> These help answer questions about parts of an array very quickly, even if the array changes often.<br>
            <strong>Fenwick Trees:</strong> A simpler version of segment trees, great for quick range queries with less memory.<br>
            <strong>Sparse Tables:</strong> These allow extremely fast queries after a one-time setup, perfect for certain problems.
        </p>

        <h2>5. Trees vs. Graphs</h2>
        <p>
            <strong>Trees:</strong> These are simple structures with no loops, like a family tree or an organization chart.<br>
            <strong>Graphs:</strong> These are more flexible, allowing loops and many connections, like a map of cities connected by roads.<br>
            <strong>When to Use:</strong> Trees are used for things like file systems (folders inside folders) and decision-making. Graphs are used for things like GPS navigation and social networks.
        </p>

        <h2>6. Sorting and Searching Algorithms</h2>
        <p>
            <strong>Sorting Algorithms</strong><br>
            <strong>Bubble Sort:</strong> Compares adjacent items and swaps them if they’re in the wrong order. It’s simple but slow for large data.<br>
            <strong>Selection Sort:</strong> Finds the smallest (or largest) item and places it in the right spot. Still slow for large data.<br>
            <strong>Insertion Sort:</strong> Builds the sorted list one item at a time. It’s faster if the list is already mostly sorted.<br>
            <strong>Merge Sort:</strong> Divides the list in half, sorts both parts, and then merges them. It’s more efficient for large data.<br>
            <strong>Quick Sort:</strong> Picks a “pivot” and divides the list into smaller parts, then sorts them. It’s fast most of the time but can slow down with bad data.<br>
            <strong>Heap Sort:</strong> Uses a heap to sort data. It’s efficient but not as fast as Merge or Quick Sort.
        </p>

        <p>
            <strong>Searching Algorithms</strong><br>
            <strong>Boyer-Moore:</strong> Searches for patterns in text quickly by skipping parts that don’t match.<br>
            <strong>Knuth-Morris-Pratt (KMP):</strong> Uses a clever trick to avoid re-checking parts of text, making it faster.<br>
            <strong>Rabin-Karp:</strong> Uses a “rolling” hash to quickly search for patterns.
        </p>

        <p>
            <strong>Graph Search Algorithms</strong><br>
            <strong>Dijkstra’s Algorithm:</strong> Finds the shortest path between two points in a network, like finding the shortest driving route between cities.<br>
            <strong>Kruskal’s Algorithm:</strong> Finds the cheapest way to connect all points in a network, like laying roads between cities with the least cost.<br>
            <strong>Prim’s Algorithm:</strong> Builds a network by adding the cheapest connections one at a time.<br>
            <strong>Floyd-Warshall Algorithm:</strong> Finds the shortest paths between all pairs of points in a network, useful in things like transportation systems.
        </p>
    </main>

    <footer>
        <p>© 2024 Algorithm Concepts</p>
    </footer>
</body>
</html>
