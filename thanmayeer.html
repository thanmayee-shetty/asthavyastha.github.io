<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Course Reflections</title>
    <link rel="stylesheet" href="styleth.css">
</head>
<body>
    <header>
        <h1>Course Reflections</h1>
    </header>
    <main>
        <section>
            <h2>Learning Algorithms</h2>
            <p>
                A course that helped me realize that it doesn't matter how much you study there is always more. Algorithms that I have learned in this course are simple but the way the person behind these algorithms was thinking is something that I tried to focus on, like understanding their thought process and why exactly they came up with that particular solution. Real time applications of such algorithms are many. For example would be the invitation problem itself. Who would want to go to different places without thinking about the shortest route. Dijkstraâ€™s, Kruskals, Floyd, Warshal etc gave us good solutions but they were still limited to only possibilities, we are the ones in the end that chose the best possible solution(at least I hope we do). All the sorting algorithms are well thought out. Of course some are inefficient for larger data sets but I would argue it is the thought that counts. Every algorithm came into picture because we thought something out of the box and that thinking is what I appreciate. There are times where in this course I have racked my brain for hours just for me to end up with a solution consisting of a few lines of code. So I would say that the main takeaway I have got from this course is to never give up on what I started. Prakash Sir has always given us the right amount of pressure so that we can work on ourselves in a proper way and that has helped me a ton while working on different codes.
            </p>
        </section>
        <section>
            <h2>Why Nature?</h2>
            <p>
                Nature is filled with patterns. Our ancestors literally made so many inventions based off these patterns. The portfolio work provided to us before had examples of patterns in nature. The concept of biomimicry is a heavily discussed topic as of now and it has also got its separate study. This study is what helped us understand how much we underestimate nature and how much of a wonder it is. The continuous growth and development of mankind can be taken as an iterative statement where we start at a new finding each time. Recursive patterns can be seen on insects and a few animals(reptiles). Such examples show us that we should be more observant of our surroundings as you may never know what may become a eureka moment for you.
            </p>
        </section>
        <section>
            <h2>Space and Time Efficiency</h2>
            <p>
                These 2 are like determining factors of whether a code is good or bad. Space efficiency is the extra space taken by a program hence if it has a higher value it is bad. Time efficiency is the time required by the program to execute a given size of input hence if this is too big thats bad too. Both of them help a programmer to understand whether he/she has written a good enough code that can be submitted as a solution to their higher ups.
            </p>
        </section>
        <section>
            <h2>Data Structures</h2>
            <p>
                The main data structures that come into my mind are trees and graphs(not implying the others aren't important). Trees are used to bring down the time required to execute the program. Similarly graphs are used to display the relationship between the entities and how they are connected. This helped us use weights that helped us with problems like navigation and how a computer network works. The funny part is how we use arrays for the implementation of both of them but the only difference is how the iterator works and what value it has. That is what helps us build these trees and graphs in the system.
            </p>
            <p>Trees are used in sorting and searching algorithms as they provide the best efficiency that can be achieved. All the variants (tree, BST, AVL, 2-3, red-black, heap, trie) help us optimize the solution as some of them are self-balancing. Some of them have trade-offs between time and space, but we need to compromise somewhere now. This doesn't mean we should not strive to find algorithms that are as time and space efficient.</p>

            <p>Traversing a tree and graph are very different. In a tree, you go from parent to child checking the required conditions to find a node. In a graph (if the edges are bidirectional), we can travel both ways and we can travel to any node through the connections given. This makes graphs more flexible for inputs, hence used in problems regarding navigation and networking. Spanning trees are graphs with no cycles or the minimum number of links required to keep the structure a graph. They help to find these short paths, which help us narrow down the possibilities of paths.</p>
        </section>

        <section>
            <h2>Approaching a Problem</h2>
            <p>I would say while writing an algorithm, always start with the brute force approach that contains all the constraints. This will help us get an idea about the structure of the algorithm. We can also go for dividing the problem into parts and applying the same approach to all those parts. After analyzing the solution that I came up with, I'll start optimizing it. I'll see where I can cut down steps, add data structures that are more space and time efficient to increase the efficiency of the overall program.</p>

            <p>If there is already an existing solution to my problem, I would take that solution and modify it to my needs. But, there are times when copy-pasting will fail. Hence, those are the times I will sit through the problem and (if I have time) will start from scratch and build a solution that would be the best for the current scenario that I was given. This is where I get the opportunity to add all the existing knowledge I have in my head and just put it out on my keyboard which would produce a solution good enough to help my client.</p>
        </section>
    </main>
    <footer>
        <p>&copy; 2024 Course Reflections. All rights reserved.</p>
    </footer>
</body>
</html>

